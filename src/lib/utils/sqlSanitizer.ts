/**
 * SQL Sanitization Utilities for LanceDB
 *
 * Prevents SQL injection vulnerabilities in vector database queries.
 * Uses input validation and escaping to ensure safe query construction.
 *
 * @module sqlSanitizer
 */

/**
 * Escapes single quotes for LanceDB SQL queries
 *
 * Note: This is a defensive measure. Parameterized queries are preferred
 * when available, but LanceDB's current API uses string-based WHERE clauses.
 *
 * @param value - The string to escape
 * @returns Escaped string safe for SQL queries
 * @throws {Error} If value is not a string
 *
 * @example
 * ```typescript
 * escapeSqlString("test'value") // Returns: "test''value"
 * escapeSqlString("normal") // Returns: "normal"
 * ```
 */
export function escapeSqlString(value: string): string {
  if (typeof value !== 'string') {
    throw new Error(
      `escapeSqlString expects a string, got ${typeof value}`
    );
  }

  // Escape single quotes by doubling them (SQL standard)
  // Example: "test'value" becomes "test''value"
  return value.replace(/'/g, "''");
}

/**
 * Validates that a string is a valid UUID v4
 *
 * Used to prevent injection attacks via malformed user/chat/message IDs.
 * All IDs in the system should be UUIDs generated by the uuid library.
 *
 * @param id - The string to validate
 * @returns True if valid UUID v4, false otherwise
 *
 * @example
 * ```typescript
 * validateUUID('123e4567-e89b-12d3-a456-426614174000') // true
 * validateUUID("' OR '1'='1") // false
 * validateUUID('not-a-uuid') // false
 * ```
 */
export function validateUUID(id: string): boolean {
  if (typeof id !== 'string') {
    return false;
  }

  // UUID v4 regex pattern
  // Format: 8-4-4-4-12 hexadecimal digits
  // Version can be 1-5, variant bits vary
  // More permissive to allow all valid UUIDs
  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

  return uuidRegex.test(id);
}

/**
 * Validates that a column name is in the allowed whitelist
 *
 * Prevents SQL injection via column name manipulation.
 * Only specific columns used in WHERE clauses are allowed.
 *
 * @param columnName - The column name to validate
 * @returns True if column is allowed, false otherwise
 *
 * @example
 * ```typescript
 * isValidColumnName('user_id') // true
 * isValidColumnName('chat_id') // true
 * isValidColumnName('malicious; DROP TABLE') // false
 * ```
 */
export function isValidColumnName(columnName: string): boolean {
  const validColumns = [
    'user_id',
    'chat_id',
    'message_id',
    'role',
    'timestamp',
  ];

  return validColumns.includes(columnName);
}

/**
 * Safely builds a SQL WHERE clause for LanceDB
 *
 * Validates column names against whitelist and escapes values.
 * Combines multiple conditions with AND.
 *
 * @param conditions - Object mapping column names to values
 * @returns Safe SQL WHERE clause (without WHERE keyword)
 * @throws {Error} If any column name is invalid
 * @throws {Error} If any value is not a string
 *
 * @example
 * ```typescript
 * safeSqlWhere({ user_id: 'abc-123', chat_id: 'xyz-789' })
 * // Returns: "user_id = 'abc-123' AND chat_id = 'xyz-789'"
 *
 * safeSqlWhere({ 'malicious; DROP': 'value' })
 * // Throws: Error('Invalid column name: malicious; DROP')
 * ```
 *
 * @security This function prevents SQL injection by:
 * 1. Whitelisting allowed column names
 * 2. Escaping single quotes in values
 * 3. Validating input types
 */
export function safeSqlWhere(conditions: Record<string, string>): string {
  const clauses = Object.entries(conditions).map(([column, value]) => {
    // Validate column name (whitelist approach)
    if (!isValidColumnName(column)) {
      throw new Error(
        `Invalid column name: ${column}. Only ${['user_id', 'chat_id', 'message_id', 'role', 'timestamp'].join(', ')} are allowed.`
      );
    }

    // Validate value type
    if (typeof value !== 'string') {
      throw new Error(
        `Column ${column} value must be a string, got ${typeof value}`
      );
    }

    // Escape the value
    const escapedValue = escapeSqlString(value);

    // Build clause
    return `${column} = '${escapedValue}'`;
  });

  return clauses.join(' AND ');
}

/**
 * Validates multiple UUIDs at once
 *
 * Useful for validating userId, chatId, messageId in a single call.
 *
 * @param ids - Object mapping ID names to values
 * @returns Validation result
 * @returns result.valid - True if all IDs are valid
 * @returns result.invalid - Array of invalid ID names
 *
 * @example
 * ```typescript
 * const result = validateUUIDs({
 *   userId: '123e4567-e89b-12d3-a456-426614174000',
 *   chatId: 'invalid-id'
 * });
 * // Returns: { valid: false, invalid: ['chatId'] }
 * ```
 */
export function validateUUIDs(
  ids: Record<string, string>
): { valid: boolean; invalid: string[] } {
  const invalid: string[] = [];

  for (const [name, id] of Object.entries(ids)) {
    if (!validateUUID(id)) {
      invalid.push(name);
    }
  }

  return {
    valid: invalid.length === 0,
    invalid,
  };
}

/**
 * Safely escapes and validates a LIMIT clause value
 *
 * Prevents injection via LIMIT clause and enforces reasonable limits.
 *
 * @param limit - The limit value (number or string)
 * @param max - Maximum allowed limit (default: 1000)
 * @returns Safe integer limit value
 * @throws {Error} If limit is not a valid positive integer
 * @throws {Error} If limit exceeds maximum
 *
 * @example
 * ```typescript
 * safeLimitClause(10) // Returns: 10
 * safeLimitClause('20') // Returns: 20
 * safeLimitClause(5000, 1000) // Throws: Error
 * safeLimitClause("'; DROP TABLE") // Throws: Error
 * ```
 */
export function safeLimitClause(
  limit: number | string,
  max: number = 1000
): number {
  // Convert string to number
  const parsed = typeof limit === 'string' ? parseInt(limit, 10) : limit;

  // Check for NaN or invalid parse (like "10; DROP TABLE" becomes 10)
  if (isNaN(parsed) || parsed < 1) {
    throw new Error('LIMIT must be a positive integer');
  }

  // SECURITY: For strings, ensure entire string is a valid number
  // This prevents "10; DROP TABLE users" from being parsed as just "10"
  if (typeof limit === 'string') {
    const trimmed = limit.trim();
    if (!/^\d+$/.test(trimmed)) {
      throw new Error('LIMIT must be a positive integer');
    }
  }

  if (parsed > max) {
    throw new Error(`LIMIT cannot exceed ${max}`);
  }

  return parsed;
}
